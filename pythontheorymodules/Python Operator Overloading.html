<!DOCTYPE html>
<html>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css2?family=Secular+One&display=swap" rel="stylesheet">
  <title>python operator overloading</title>
  <style type="text/css">
    *
    {
      font-family: 'Secular One', sans-serif;
    }
  </style>
</head>
<body>
<div class="container mt-5">
  <div class="card">

    <div class="card-body">
      <h3 class="text-primary"> Python operator overloading</h3>



	<h5>Python operators work for built-in classes. But the same operator behaves differently with different types. For example, the + operator will perform arithmetic addition on two numbers, merge two lists, or concatenate two strings.
This feature in Python that allows the same operator to have different meaning according to the context is called operator overloading.
So what happens when we use them with objects of a user-defined class? Let us consider the following class, which tries to simulate a point in 2-D </h5>





<h3 class="text-primary"> Python special functions</h3>
<h5>Class functions that begin with double underscore __ are called special functions in Python.
These functions are not the typical functions that we define for a class. The __init__() function we defined above is one of them. It gets called every time we create a new object of that class.
There are numerous other special functions in Python. Visit Python Special Functions to learn more about them.
Using special functions, we can make our class compatible with built-in functions.</h5>

<h5>That's better. Turns out, that this same method is invoked when we use the built-in function str() or format().
>>> str(p1)'(2,3)'
>>> format(p1)'(2,3)'
So, when you use str(p1) or format(p1), Python internally calls the p1.__str__() method. Hence the name, special functions.
Now let's go back to operator overloading.

Overloading the + Operator
To overload the + operator, we will need to implement __add__() function in the class. With great power comes great responsibility. We can do whatever we like, inside this function. But it is more sensible to return a Point object of the coordinate sum.
</h5>
<h5>What actually happens is that, when you use p1 + p2, Python calls p1.__add__(p2) which in turn is Point.__add__(p1,p2). After this, the addition operation is carried out the way we specified.
Similarly, we can overload other operators as well. The special function that we need to implement is tabulated below.


Similarly, the special functions that we need to implement, to overload other comparison operators are tabulated below.</h5>


</body>
</html>